export const actions = [
  {
    meta: Object.freeze({
      action: "parse",
      language: "lua",
    }),

    patterns: {
      commentStart: /^\s*---\s?(.*)$/, // Match start of a docblock
      commentContent: /^\s*---\s?(?<content>.*)$/, // Match continuation of a docblock
      functionPattern:
        /^\s*function\s+(\w+)?([:.])?\s*([\w_]+)\s*\((.*?)\)\s*(?:end)?$/,
      blankLine: /^\s*$/, // Match blank lines
      argArray: /\w+(\s*\[\s *\]\s *)?/,
      tagContent:
        /^(?<name>(\.{3}|\w+)) (?<type>[a-zA-Z]+(?:\?|(?:\|[a-zA-Z]+\[\])?)) - (?<content>.+)$/,
      returnContent: /^\s*(?<type>[\w+[\]]+)\s+#\s+(?<content>.*)?$/,
    },

    tags: {
      all: ["name", "param", "return", "example"],
      singletons: ["name", "return", "example"],
      convert: {returns: "return"},
      noContent: ["name"],
      normalize: (tag) => this.tags.convert[tag] || tag,
      isTagValid(tag) {
        const tags = this.tags
        return [
          ...tags.all,
          ...Object.keys(tags.convert),
          ...Object.values(tags.convert),
        ].includes(tag)
      }
    },

    resetState() {
      this.processingComment = false
      this.currentTag = null
    },

    init(config) {
      this.parent = config.parent
      this.log = config.log
      this.resetState()
      this.regex = {
        ...this.patterns,
        tag: new RegExp(
          `^\\s*---@(?<tag>${[...this.tags.all].join("|")})\\s?(?<content>.*)$`,
        ),
      }
    },

    /**
     * Parse the content of a Lua file and send it to BeDoc
     *
     * @param {string} file The file name to parse.
     * @param {object} content The content of the file to parse.
     * @returns {object} The result of the parse operation.
     */
    async parse(file, content) {
      // Setup utilities
      const log = this.log
      const debug = log.newDebug()

      debug(`Parsing file %s`, 2, file)

      this.resetState()
      const result = {
        file,
        raw: content,
        functions: [],
      }

      try {
        const lines = content.split(/\r?\n/)
        const funcs = []
        let func = null
        let position = 0,
          length = lines.length

        for(position; position < length; position++) {
          const line = lines[position]
          const lineTrimmed = line.trim()

          // Skip empty lines unless we're processing a comment
          if(!this.processingComment && !lineTrimmed.length)continue
          // Check for start of doc comment block
          else if(this.isCommentStart(lineTrimmed)) {
            // Restart with a new function
            func = this.newFunction()
            // Rewind one line to re-process this line
            position--
          } else if(this.isFunctionLine(lineTrimmed)) {
            const {status, message: functionName} =
              this.determineFunctionName(lineTrimmed)
            if(status === "success") {
              funcs.push({...func, name: functionName})
            } else
              return {
                status: "error",
                file,
                line,
                lineNumber: position + 1,
                message: functionName,
              }

            continue
          } else if(this.processingComment) {
            // If we are not a comment, we should turn off comment tracking
            // and then continue so that we can test for function definition
            if(!this.isComment(lineTrimmed)) {
              this.processingComment = false
              position--
              continue
            }
            const processed = this.processLine({line, func, file, position})
            const {status, message} = processed
            if(status === "error")
              return {
                status: "error",
                file,
                line,
                lineNumber: position + 1,
                message,
              }
          }
        }

        result.functions = funcs

        debug(`Parsed file %s`, 2, file)
        debug(`Result: %j`, 4, result)

        return {status: "success", result}
      } catch(e) {
        return {
          status: "error",
          file,
          line: null,
          lineNumber: null,
          message: e.message,
        }
      }
    },

    isComment(line) {
      return this.regex.commentContent.test(line)
    },

    /**
     * Determines if a line is a comment start.
     *
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is the start of a comment.
     */
    isCommentStart(line) {
      // Only consider it a new doc block start if we're not already in a
      // comment
      return !this.processingComment && this.regex.commentStart.test(line)
    },

    /**
     * Create a new function object.
     *
     * @returns {object} A new function object.
     */
    newFunction() {
      this.resetState()
      this.processingComment = true
      return {}
    },

    /**
     * Generate a formatted message.
     *
     * @param {string} message - The message to log.
     * @param {string} funcName - The function name that generated the message.
     * @param {string} file - The file name that generated the message.
     * @param {number} position - The line number in the source file.
     * @param {string} line - The line of code in the source file.
     * @returns {string} The formatted message.
     */
    generateMessage(message, funcName, file, position, line) {
      return `[${funcName}] ${message}: ${file}:${position + 1} - ${line}`
    },

    /**
     * Process a line of code.
     *
     * @param {object} params - The parameters for processing the line.
     * @param {string} params.line - The line to process.
     * @param {object} params.func - The function object being processed.
     * @param {string} params.file - The file name being processed.
     * @param {number} params.position - The line number being processed.
     * @returns {object} The result of the line processing.
     */
    processLine({line, func, file, position}) {
      const lineTrimmed = line.trim()
      const msg = this.generateMessage

      if(!func)
        return {
          status: "error",
          message: msg(
            "No function context",
            "processLine",
            file,
            position,
            line,
          ),
        }

      const tagMatches = this.regex.tag.exec(line)

      if(tagMatches) {
        const {tag, content} = tagMatches.groups
        if(!this.tags.isTagValid.call(this, tag))
          return {
            status: "error",
            message: msg(
              `Invalid tag: ${tag}`,
              "processLine",
              file,
              position,
              line,
            ),
          }

        const singleton = this.tags.singletons.includes(tag)
        const noContent = this.tags.noContent.includes(tag)

        if(noContent && content) {
          func[tag] = func[tag] || content
          return {status: "success", message: "Processed tag"}
        }

        if(singleton) {
          if(func[tag])
            return {
              status: "error",
              message: msg(
                `Singleton tag already exists: ${tag}`,
                "processLine",
                file,
                position,
                line,
              ),
            }
          func[tag] = null
        } else {
          func[tag] = func[tag] || []
        }

        this.currentTag = tag
        this.section = null

        if(tag === "return") {
          this.section = {tag, name: null}
          const tagContentMatches = this.regex.returnContent.exec(content)
          if(tagContentMatches) {
            const {type, content} = tagContentMatches.groups
            if(!type)
              return {
                status: "error",
                message: msg(
                  `Missing return type: ${tag}`,
                  "processLine",
                  file,
                  position,
                  line,
                ),
              }
            if(!content) {
              this.core.logger.warn(
                msg(
                  `Missing return content: ${tag}`,
                  "processLine",
                  file,
                  position,
                  line,
                ),
              )
              singleton
                ? (func[tag] = {type, content: []})
                : func[tag].push({type, content: []})
            } else {
              const types = type.split(",").map((t) => t.trim())
              singleton
                ? (func[tag] = {type: types, content: [content]})
                : func[tag].push({type: types, content: [content]})
            }
          } else
            return {
              status: "error",
              message: msg(
                "Failed to parse return tag",
                "processLine",
                file,
                position,
                line,
              ),
            }
        } else if(!noContent) {
          const tagContentMatches = this.regex.tagContent.exec(content)
          if(tagContentMatches) {
            const {type, name, content} = tagContentMatches.groups
            if(!type)
              return {
                status: "error",
                message: msg(
                  "Missing tag type",
                  "processLine",
                  file,
                  position,
                  line,
                ),
              }
            if(!name)
              return {
                status: "error",
                message: msg(
                  "Missing tag name",
                  "processLine",
                  file,
                  position,
                  line,
                ),
              }
            this.section = {tag, name}
            singleton
              ? (func[tag] = {type, name, content: [content]})
              : func[tag].push({type, name, content: [content]})
          } else {
            // This is probably a singleton
            if(this.tags.singletons.includes(tag)) {
              this.section = {tag, name: null}
              func[tag] = []
            } else {
              return {
                status: "error",
                message: msg(
                  "Failed to parse tag",
                  "processLine",
                  file,
                  position,
                  line,
                ),
              }
            }
          }
        }
        return {status: "success", message: "Processed tag"}
      }

      // Process multiline content
      if(this.currentTag) {
        if(this.section?.name) {
          const currentTag = this.currentTag
          const {tag, name} = this.section

          const index = name
            ? func[tag].findIndex((item) => item.name === name)
            : null
          const tagMatch = this.regex.commentContent.exec(lineTrimmed)

          if(tagMatch && tagMatch.groups?.content) {
            if(index > -1) {
              func[currentTag][index].content.push(tagMatch.groups.content)
            } else {
              func[currentTag].content.push(tagMatch.groups.content)
            }
          } else {
            if(index) func[currentTag][index].content.push("")
            else func[currentTag].content.push("")
          }
        } else {
          const {tag} = this.section
          const commentMatch = this.regex.commentContent.exec(lineTrimmed)
          if(commentMatch && commentMatch.groups?.content) {
            if(func[tag].content)
              func[tag].content.push(commentMatch.groups.content)
            else func[tag].push(commentMatch.groups.content)
          } else {
            if(func[tag].content) func[tag].content.push("")
            else func[tag].push("")
          }
        }
        return {status: "success", message: "Processed tag continuation"}
      }

      // If not a special tag, treat as description
      const descMatch = this.regex.commentContent.exec(lineTrimmed)
      if(descMatch && descMatch.groups?.content) {
        func.description = func.description || []
        func.description.push(descMatch.groups.content)
        return {status: "success", message: "Processed description"}
      } else {
        func.description = func.description || []
        func.description.push("")
        return {status: "success", message: "Processed description"}
      }
    },

    /**
     * Determines if a line is a function definition.
     *
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is a function definition.
     */
    isFunctionLine(line) {
      return !this.processingComment && this.regex.functionPattern.test(line)
    },

    /**
     * Determine the function name from a line.
     *
     * @param {string} line - The line to determine the function name from.
     * @returns {object} The result of the function name determination.
     */
    determineFunctionName(line) {
      const match = this.regex.functionPattern.exec(line)
      const err = {
        status: "error",
        message: `Failed to extract function from line: ${line}`,
      }

      if(!match) return err

      const name = match[3]
      if(!name) return err

      return {status: "success", message: name}
    },
  },
]

export const contracts = [
  `
---
provides:
  root:
    dataType: object
    contains:
      functions:
        dataType: object[]
        contains:
          name:
            dataType: string
          description:
            dataType: string[]
          param:
            dataType: object[]
            contains:
              type:
                dataType: string
              name:
                dataType: string
              content:
                dataType: string[]
          return:
            dataType: object
            contains:
              type:
                dataType: string
              content:
                dataType: string[]
          example:
            dataType: string[]
`,
]
