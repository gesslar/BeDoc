export const actions = [
  {
    meta: Object.freeze({
      action: "parse",
      language: "lua",
    }),

    patterns: {
      commentStart: /^\s*---\s?(.*)$/, // Match start of a docblock
      commentContent: /^\s*---\s?(?<content>.*)$/, // Match continuation of a docblock
      functionPattern:
        /^\s*function\s+(?<name>(?<scope>[a-zA-Z_]\w*(?=[.:]))?(?<delimiter>[.:])?(?<method>[a-zA-Z_]\w*))\s*\((?<parms>.+)?\)\s*(?:end)?$/,
      blankLine: /^\s*$/, // Match blank lines
      argArray: /\w+(\s*\[\s *\]\s *)?/,
      tagContent: /^(?<name>.*) (?<type>.*) - (?<content>.+)$/,
      returnContent: /^\s*(?<type>.*)\s+#\s+(?<content>.*)?$/,
    },

    /**
     * Parse a Lua type string and split it into an array of types.
     * @param {string} typeStr The type string to parse (e.g., "number|nil",
     *  "string?").
     * @returns {string[]} An array of parsed types (e.g., ["number", "nil"]).
     */
    parseLuaType(typeStr) {
      if (!typeStr || typeof typeStr !== "string") return []

      const types = []

      // Handle nullable shorthand (e.g., "number?")
      const nullableMatch = typeStr.match(/(\w+)\?/)
      if (nullableMatch) {
        types.push(nullableMatch[1], "nil")
        typeStr = typeStr.replace(/\w+\?/, nullableMatch[1]) // Normalize by removing the "?"
      }

      // Handle union types (e.g., "number|nil")
      const unionTypes = typeStr.split("|").map(type => type.trim())
      for (const type of unionTypes) {
        if (!types.includes(type)) {
          types.push(type) // Avoid duplicates
        }
      }

      return types
    },

    tags: {
      all: ["name", "param", "return", "example"],
      singletons: ["name", "return", "example"],
      convert: { returns: "return" },
      noContent: ["name"],
      normalize: tag => this.tags.convert[tag] || tag,
      isTagValid(tag) {
        const tags = this.tags
        return [
          ...tags.all,
          ...Object.keys(tags.convert),
          ...Object.values(tags.convert),
        ].includes(tag)
      }
    },

    resetState(full = false) {
      if (full === true)
        this.processing = false

      this.processingComment = false
      this.currentTag = null
    },

    async setup({ parent, log }) {
      this.parent = parent
      this.log = log
      this.resetState()
      this.regex = {
        ...this.patterns,
        tag: new RegExp(
          `^\\s*---@(?<tag>${[...this.tags.all].join("|")})\\s?(?<content>.*)$`,
        ),
      }
    },

    /**
     * Parse the content of an Lua file and send it to BeDoc
     * @param {object} module The file name to parse.
     * @param {string} module.file The file object representing the current
     *  being processed
     * @param {object} module.moduleContent The content of the file to parse.
     * @returns {object} The result of the parse operation.
     */
    async run(module) {
      const { file: { module: moduleName }, moduleContent } = module

      // Setup utilities
      const log = this.log
      const debug = log.newDebug()

      debug(`Parsing file %s`, 2, module)

      this.resetState()
      const result = []

      const lines = moduleContent.split(/\r?\n/)
      let func = null
      let position = 0
      const length = lines.length

      for (; position < length; position++) {
        const line = lines[position]
        const lineTrimmed = line.trim()

        // Skip empty lines unless we're processing a comment
        if (!this.processingComment && !lineTrimmed.length) {
          continue
          // Check for start of doc comment block
        } else if (this.isCommentStart(lineTrimmed)) {
          // Restart with a new function
          func = this.newFunction()
          // Rewind one line to re-process this line
          position--
        } else if (this.isFunctionLine(lineTrimmed)) {
          const { status, signature } =
            this.extractFunctionSignature(lineTrimmed, func)

          this.resetState(true)

          if (status === "success") {
            // Only do this if we actually have any content, tho
            if (Object.keys(func ?? {}).length > 0)
              result.push({ ...func, signature })
            else
              continue
          } else {
            return {
              status: "error",
              file: moduleName,
              line,
              lineNumber: position + 1,
              error: new Error("Problem determining function name.")
            }
          }

          continue
        } else if (this.processingComment) {
          // If we are not a comment, we should turn off comment tracking
          // and then continue so that we can test for function definition
          if (!this.isComment(lineTrimmed)) {
            this.processingComment = false
            position--
            continue
          }

          const processed = this.processLine({
            line,
            func,
            file: moduleName,
            position
          })

          const { status, error } = processed
          if (status === "error")
            return {
              status: "error",
              file: moduleName,
              line,
              lineNumber: position + 1,
              error: error
            }
        }
      }

      return { status: "success", result }
    },

    isComment(line) {
      return this.regex.commentContent.test(line)
    },

    /**
     * Determines if a line is a comment start.
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is the start of a comment.
     */
    isCommentStart(line) {
      // Only consider it a new doc block start if we're not already in a
      // comment, or not processing at all.
      return !this.processing &&
        !this.processingComment &&
        this.regex.commentStart.test(line)
    },

    /**
     * Create a new function object.
     * @returns {object} A new function object.
     */
    newFunction() {
      this.resetState()
      this.processing = true
      this.processingComment = true
      return {}
    },

    /**
     * Generate a formatted message.
     * @param {string} message - The message to log.
     * @param {string} funcName - The function name that generated the message.
     * @param {string} file - The file name that generated the message.
     * @param {number} position - The line number in the source file.
     * @param {string} line - The line of code in the source file.
     * @returns {string} The formatted message.
     */
    generateMessage(message, funcName, file, position, line) {
      return `[${funcName}] ${message}: ${file}:${position + 1} - ${line}`
    },

    /**
     * Process a line of code.
     * @param {object} params - The parameters for processing the line.
     * @param {string} params.line - The line to process.
     * @param {object} params.func - The function object being processed.
     * @param {string} params.file - The file name being processed.
     * @param {number} params.position - The line number being processed.
     * @returns {object} The result of the line processing.
     */
    processLine({ line, func, file, position }) {
      const lineTrimmed = line.trim()
      const msg = this.generateMessage

      if (!func)
        return {
          status: "error",
          error: new Error(msg("No function context", "processLine", file, position, line)),
        }

      const tagMatches = this.regex.tag.exec(line)

      if (tagMatches) {
        const { tag, content } = tagMatches.groups

        if (!this.tags.isTagValid.call(this, tag))
          return {
            status: "error",
            error: new Error(msg(`Invalid tag: ${tag}`, "processLine", file, position, line)),
          }

        const singleton = this.tags.singletons.includes(tag)
        const noContent = this.tags.noContent.includes(tag)

        if (noContent && content) {
          func[tag] = func[tag] || content

          return { status: "success", message: "Processed tag" }
        }

        if (singleton) {
          if (func[tag])
            return {
              status: "error",
              error: new Error(msg(`Singleton tag already exists: ${tag}`, "processLine", file, position, line)),
            }

          func[tag] = null
        } else {
          func[tag] = func[tag] || []
        }

        this.currentTag = tag
        this.section = null

        if (tag === "return") {
          this.section = { tag, name: null }

          const tagContentMatches = this.regex.returnContent.exec(content)

          if (tagContentMatches) {
            const { type, content } = tagContentMatches.groups

            if (!type)
              return {
                status: "error",
                error: new Error(msg(`Missing return type: ${tag}`, "processLine", file, position, line)),
              }

            if (!content) {
              this.core.logger.warn(
                msg(`Missing return content: ${tag}`, "processLine", file, position, line),
              )
              singleton
                ? (func[tag] = { type, content: [] })
                : func[tag].push({ type, content: [] })
            } else {
              const types = type.split(",").map(t => t.trim())

              singleton
                ? (func[tag] = { type: types, content: [content] })
                : func[tag].push({ type: types, content: [content] })
            }
          } else {
            return {
              status: "error",
              error: new Error(msg("Failed to parse return tag", "processLine", file, position, line)),
            }
          }
        } else if (!noContent) {
          const tagContentMatches = this.regex.tagContent.exec(content)

          if (tagContentMatches) {
            const { type, name, content } = tagContentMatches.groups

            if (!type)
              return {
                status: "error",
                error: new Error(msg("Missing tag type", "processLine", file, position, line)),
              }

            if (!name)
              return {
                status: "error",
                error: new Error(msg("Missing tag name", "processLine", file, position, line)),
              }

            this.section = { tag, name }
            singleton
              ? (func[tag] = { type, name, content: [content] })
              : func[tag].push({ type, name, content: [content] })
          } else {
            // This is probably a singleton
            if (this.tags.singletons.includes(tag)) {
              this.section = { tag, name: null }
              func[tag] = []
            } else {
              return {
                status: "error",
                error: new Error(msg("Failed to parse tag", "processLine", file, position, line)),
              }
            }
          }
        }

        return { status: "success", message: "Processed tag" }
      }

      // Process multiline content
      if (this.currentTag) {
        if (this.section?.name) {
          const currentTag = this.currentTag
          const { tag, name } = this.section

          const index = name
            ? func[tag].findIndex(item => item.name === name)
            : null
          const tagMatch = this.regex.commentContent.exec(lineTrimmed)

          if (tagMatch && tagMatch.groups?.content) {
            if (index > -1)
              func[currentTag][index].content.push(tagMatch.groups.content)
            else
              func[currentTag].content.push(tagMatch.groups.content)
          } else {
            if (index)
              func[currentTag][index].content.push("")
            else
              func[currentTag].content.push("")
          }
        } else {
          const { tag } = this.section
          const commentMatch = this.regex.commentContent.exec(lineTrimmed)
          if (commentMatch && commentMatch.groups?.content) {
            if (func[tag].content)
              func[tag].content.push(commentMatch.groups.content)
            else
              func[tag].push(commentMatch.groups.content)
          } else {
            if (func[tag].content)
              func[tag].content.push("")
            else
              func[tag].push("")
          }
        }

        return { status: "success", message: "Processed tag continuation" }
      }

      // If not a special tag, treat as description
      const descMatch = this.regex.commentContent.exec(lineTrimmed)
      if (descMatch && descMatch.groups?.content) {
        func.description = func.description || []
        func.description.push(descMatch.groups.content)

        return { status: "success", message: "Processed description" }
      } else {
        func.description = func.description || []
        func.description.push("")

        return { status: "success", message: "Processed description" }
      }
    },

    /**
     * Determines if a line is a function definition.
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is a function definition.
     */
    isFunctionLine(line) {
      return this.processing &&
        !this.processingComment &&
        this.regex.functionPattern.test(line)
    },

    /**
     * Determine the function name from a line.
     * @param {string} line - The line to determine the function name from.
     * @param {object} func - The function so far
     * @returns {object} The result of the function name determination.
     */
    extractFunctionSignature(line, func) {
      const match = this.regex.functionPattern.exec(line)

      if (!match?.groups?.name)
        return {
          status: "error",
          error: new Error(`Failed to extract function from line: ${line}`),
        }

      const groups = match.groups
      const signature = {
        name: groups.name,
        scope: groups.scope,
        delimiter: groups.delimiter,
        method: groups.method,
        modifiers: [],
        access: "",
        type: func.return?.type.map(r => r.trim()).join(", ") ?? "null",
        parameters: groups.parms?.split(",").map(p => p.trim()) ?? []
      }

      return { status: "success", signature }
    },
  },
]

export const contracts = [
  `
provides:
  type: object
  properties:
    functions:
      type: array
      items:
        type: object
        properties:
          name:
            type: string
          description:
            type: array
            items:
              type: string
          param:
            type: array
            items:
              type: object
              properties:
                type:
                  type: string
                name:
                  type: string
                content:
                  type: array
                  items:
                    type: string
          return:
            type: object
            properties:
              type:
                type: string
              content:
                type: array
                items:
                  type: string
          example:
            type: array
            items:
              type: string

`,
]
