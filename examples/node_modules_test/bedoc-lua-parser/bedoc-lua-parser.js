/**
 * The meta information for this parser.
 */
const meta = Object.freeze({
  language: "lua",
  languageExtension: ".lua",
})

let logger

const patterns = {
  commentStart: /^\s*---\s?(.*)$/, // Match start of a docblock
  commentContent: /^\s*---\s?(?<content>.*)$/, // Match continuation of a docblock
  functionPattern: /^\s*function\s+(\w+)?([:.])?\s*([\w_]+)\s*\((.*?)\)\s*(?:end)?$/,
  blankLine: /^\s*$/, // Match blank lines
  argArray: /\w+(\s*\[\s *\]\s *)?/,
  tagContent: /^(?<name>(\.{3}|\w+)) (?<type>[a-zA-Z]+(?:\?|(?:\|[a-zA-Z]+\[\])?)) - (?<content>.+)$/,
  returnContent: /^\s*(?<type>[\w+[\]]+)\s+#\s+(?<content>.*)?$/,
}

const tags = {
  all: ["name", "param", "return", "example"],
  singletons: ["name", "return", "description", "example"],
  convert: { returns: "return" },
  noContent: ["name"],
  normalize: tag => tags.convert[tag] || tag,
  isValid: tag =>
    tags.all.includes(tag) ||
      Object.keys(tags.convert).includes(tag) ||
      Object.values(tags.convert).includes(tag)
  ,
}

/**
 * A class that parses Lua code and extracts documentation.
 */
class Parser {
  #core
  #regex
  #processingComment
  #currentTag
  #section

  /**
   * Ugh, ESLint, this is a _constructor_. You know thaaaat.
   * @param {object} core - The core object containing utilities.
   */
  constructor(core) {
    this.#resetState()
    this.#core = core
    this.#regex = {
      ...patterns,
      tag: new RegExp(`^\\s*---@(?<tag>${[...tags.all].join("|")})\\s?(?<content>.*)$`),
    }
  }

  #resetState() {
    this.#processingComment = false
    this.#currentTag = null
  }

  /**
   * Parse the content of a Lua file and send it to BeDoc
   * @param {string} file The file name to parse.
   * @param {object} content The content of the file to parse.
   * @returns {object} The result of the parse operation.
   */
  async parse(file, content) {
    // Setup utilities
    logger = this.logger

    const debug = logger.newDebug()

    debug(`Parsing file \`${file}\``, 2)
    this.#resetState()
    const result = {
      file,
      raw: content,
      functions: [],
    }

    try {
      const lines = content.split(/\r?\n/)
      const funcs = []
      let func = null
      let position = 0, length = lines.length

      for(position; position < length; position++) {
        const line = lines[position]
        const lineTrimmed = line.trim()

        // Skip empty lines unless we're processing a comment
        if(!this.#processingComment && !lineTrimmed.length)
          continue
        // Check for start of doc comment block
        else if(this.#isCommentStart(lineTrimmed)) {
          // Restart with a new function
          func = this.#newFunction()
          // Rewind one line to re-process this line
          position--
        } else if(this.#isFunctionLine(lineTrimmed)) {
          const {status, message: functionName} =
            this.#determineFunctionName(lineTrimmed)
          if(status === "success") {
            funcs.push({ ...func, name: functionName })
          } else
            return {status: "error", file, line, lineNumber: position + 1, message: functionName}

          continue
        } else if(this.#processingComment) {
          // If we are not a comment, we should turn off comment tracking
          // and then continue so that we can test for function definition
          if(!this.#isComment(lineTrimmed)) {
            this.#processingComment = false
            position--
            continue
          }
          const processed = this.#processLine({line, func, file, position})
          const { status, message } = processed
          if(status === "error")
            return {status: "error", file, line, lineNumber: position + 1, message}
        }
      }

      result.functions = funcs

      debug(`Parsed file \`${file}\``, 2)
      debug(`Result: ${JSON.stringify(result, null, 1)}`, 4)

      return {status: "success", result}
    } catch(e) {
      return {status: "error", file, line: null, lineNumber: null, message: e.message}
    }
  }

  #isComment(line) {
    return this.#regex.commentContent.test(line)
  }

  /**
   * Determines if a line is a comment start.
   * @param {string} line - The line to check.
   * @returns {boolean} Whether the line is the start of a comment.
   */
  #isCommentStart(line) {
    // Only consider it a new doc block start if we're not already in a comment
    return !this.#processingComment && this.#regex.commentStart.test(line)
  }

  /**
   * Create a new function object.
   * @returns {object} A new function object.
   */
  #newFunction() {
    this.#resetState()
    this.#processingComment = true
    return {}
  }

  /**
   * Generate a formatted message.
   * @param {string} message - The message to log.
   * @param {string} funcName - The function name that generated the message.
   * @param {string} file - The file name that generated the message.
   * @param {number} position - The line number in the source file.
   * @param {string} line - The line of code in the source file.
   * @returns {string} The formatted message.
   */
  #generateMessage(message, funcName, file, position, line) {
    return `[${funcName}] ${message}: ${file}:${position + 1} - ${line}`
  }

  /**
   * Process a line of code.
   * @param {object} params - The parameters for processing the line.
   * @param {string} params.line - The line to process.
   * @param {object} params.func - The function object being processed.
   * @param {string} params.file - The file name being processed.
   * @param {number} params.position - The line number being processed.
   * @returns {object} The result of the line processing.
   */
  #processLine({ line, func, file, position }) {
    const lineTrimmed = line.trim()
    const msg = this.#generateMessage

    if(!func)
      return { status: "error", message: msg("No function context", "processLine", file, position, line) }

    const tagMatches = this.#regex.tag.exec(line)

    if(tagMatches) {
      const { tag, content } = tagMatches.groups
      if(!tags.isValid(tag))
        return { status: "error", message: msg(`Invalid tag: ${tag}`, "processLine", file, position, line) }

      const singleton = tags.singletons.includes(tag)
      const noContent = tags.noContent.includes(tag)

      if(noContent && content) {
        func[tag] = func[tag] || content
        return { status: "success", message: "Processed tag" }
      }

      if(singleton) {
        if(func[tag])
          return { status: "error", message: msg(`Singleton tag already exists: ${tag}`, "processLine", file, position, line) }
        func[tag] = null
      } else {
        func[tag] = func[tag] || []
      }

      this.#currentTag = tag
      this.#section = null

      if(tag === "return") {
        this.#section = { tag, name: null }
        const tagContentMatches = this.#regex.returnContent.exec(content)
        if(tagContentMatches) {
          const { type, content } = tagContentMatches.groups
          if(!type)
            return { status: "error", message: msg(`Missing return type: ${tag}`, "processLine", file, position, line) }
          if(!content) {
            this.#core.logger.warn(msg(`Missing return content: ${tag}`, "processLine", file, position, line))
            singleton
              ? func[tag] = { type, content: [] }
              : func[tag].push({ type, content: [] })
          } else {
            const types = type.split(",").map(t => t.trim())
            singleton
              ? func[tag] = { type: types, content: [content] }
              : func[tag].push({ type: types, content: [content] })
          }
        } else
          return { status: "error", message: msg("Failed to parse return tag", "processLine", file, position, line) }
      } else if(!noContent) {
        const tagContentMatches = this.#regex.tagContent.exec(content)
        if(tagContentMatches) {
          const { type, name, content } = tagContentMatches.groups
          if(!type)
            return { status: "error", message: msg("Missing tag type", "processLine", file, position, line) }
          if(!name)
            return { status: "error", message: msg("Missing tag name", "processLine", file, position, line) }
          this.#section = { tag, name }
          singleton
            ? func[tag] = { type, name, content: [content] }
            : func[tag].push({ type, name, content: [content] })
        } else {
          // This is probably a singleton
          if(tags.singletons.includes(tag)) {
            this.#section = { tag, name: null }
            func[tag] = []
          } else {
            return { status: "error", message: msg("Failed to parse tag", "processLine", file, position, line) }
          }
        }
      }
      return { status: "success", message: "Processed tag" }
    }

    // Process multiline content
    if(this.#currentTag) {
      if(this.#section?.name) {
        const currentTag = this.#currentTag
        const { tag, name } = this.#section

        const index = name
          ? func[tag].findIndex(item => item.name === name)
          : null
        const tagMatch = this.#regex.commentContent.exec(lineTrimmed)

        if(tagMatch && tagMatch.groups?.content) {
          if(index > -1) {
            func[currentTag][index].content.push(tagMatch.groups.content)
          } else {
            func[currentTag].content.push(tagMatch.groups.content)
          }
        } else {
          if(index)
            func[currentTag][index].content.push("")
          else
            func[currentTag].content.push("")
        }
      } else {
        const { tag } = this.#section
        const commentMatch = this.#regex.commentContent.exec(lineTrimmed)
        if(commentMatch && commentMatch.groups?.content) {
          if(func[tag].content)
            func[tag].content.push(commentMatch.groups.content)
          else
            func[tag].push(commentMatch.groups.content)
        } else {
          if(func[tag].content)
            func[tag].content.push("")
          else
            func[tag].push("")
        }
      }
      return { status: "success", message: "Processed tag continuation" }
    }

    // If not a special tag, treat as description
    const descMatch = this.#regex.commentContent.exec(lineTrimmed)
    if(descMatch && descMatch.groups?.content) {
      func.description = func.description || []
      func.description.push(descMatch.groups.content)
      return { status: "success", message: "Processed description" }
    } else {
      func.description = func.description || []
      func.description.push("")
      return { status: "success", message: "Processed description" }
    }
  }

  /**
   * Determines if a line is a function definition.
   * @param {string} line - The line to check.
   * @returns {boolean} Whether the line is a function definition.
   */
  #isFunctionLine(line) {
    return !this.#processingComment && this.#regex.functionPattern.test(line)
  }

  /**
   * Determine the function name from a line.
   * @param {string} line - The line to determine the function name from.
   * @returns {object} The result of the function name determination.
   */
  #determineFunctionName(line) {
    const match = this.#regex.functionPattern.exec(line)
    const err = {status: "error", message: `Failed to extract function from line: ${line}`}

    if(!match)
      return err

    const name = match[3]
    if(!name)
      return err

    return {status: "success", message: name}
  }
}

export {meta, Parser}
