export const actions = [
  {
    meta: Object.freeze({
      action: "print",
      format: "wikitext",
    }),

    init(config) {
      this.parent = config.parent
      this.log = config.log
      this.documentExtension = ".txt"
    },

    /**
     * Print the results to a buffer and return it to BeDoc for writing.
     * @param {string} module - The module name to print.
     * @param {object} content - The content to be printed.
     * @returns {Promise<object>} The result of the print operation.
     */
    async print(module, content) {
      const debug = this.log.newDebug()
      const hook = this.hook
      const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS

      await hook(START, {module, content})

      const work = content.functions.sort((a, b) =>
        a.name.localeCompare(b.name),
      )
      const output = []

      const printName = async(section) => {
        await hook(ENTER, {name: "name", section})
        const outputName = `== ${section.name} ==\n`
        const outputResult = await hook(EXIT, {
          name: "name",
          content: outputName,
        })
        return outputResult ?? outputName
      }

      const printDescription = async(section) => {
        debug(
          `[printDescription] section: ${JSON.stringify(section, null, 1)}`,
          4,
        )
        await hook(ENTER, {name: "description", section})
        const outputDescription = section.description?.length
          ? section.description.map((line) => line.trim()).join("\n")
          : ""
        const outputResult = await hook(EXIT, {
          name: "description",
          content: outputDescription,
        })
        return outputResult ?? outputDescription
      }

      const printParams = async(section) => {
        await hook(ENTER, {name: "param", section})
        const outputParams = []

        if(!section.param) return outputParams

        for(const param of section.param || []) {
          const isOptional = param.content.some((line) =>
            line.toLowerCase().includes("(optional)"),
          )
          const content = param.content
            .map((line) => line.replace("(optional)", "").trim())
            .join(" ") // Flatten multiline descriptions into one line
            .replace(/\s+/g, " ") // Ensure clean spacing

          const optionalTag =
            param.optional || isOptional ? ", ''optional''" : ""
          const result = `* '''<code>${param.name}</code>''' (<code>${param.type}</code>${optionalTag}): ${content}`
          outputParams.push(result)
        }
        const outputResult = await hook(EXIT, {
          name: "param",
          content: outputParams,
        })
        return outputResult ?? outputParams
      }

      const printReturns = async(section) => {
        await hook(ENTER, {name: "return", section})
        // Then the returns
        const outputReturns = section.return
          ? `=== Returns ===\n\n${
            section.return.content
              ? `'''<code>${section.return.type}</code>''': ${section.return.content}`
              : `'''<code>${section.return.type}</code>'''`
          }`
          : ""

        const outputResult = await hook(EXIT, {
          name: "return",
          content: outputReturns,
        })
        return outputResult ?? outputReturns
      }

      const printExample = async(section) => {
        await hook(ENTER, {name: "example", section})
        const outputExample = section.example?.length
          ? "== Example ==\n\n" + section.example.join("\n")
          : ""
        const outputResult = await hook(EXIT, {
          name: "example",
          content: outputExample,
        })
        return outputResult ?? outputExample
      }

      for(const section of work) {
        await hook(SECTION_LOAD, {section})

        // First the function name
        const outputName = await printName(section)

        // Then the description
        const outputDescription = await printDescription(section)

        // Then the parameters
        const outputParams = await printParams(section)

        // Then the returns
        const outputReturns = await printReturns(section)

        // Then the example
        const outputExample = await printExample(section)

        output.push(
          `${outputName}` +
            `${outputDescription.length ? `\n${outputDescription}\n` : ""}` +
            `${outputParams.length ? `\n${outputParams.join("\n")}\n` : ""}` +
            `${outputReturns.length ? `\n${outputReturns}\n` : ""}` +
            `${outputExample.length ? `\n${outputExample}\n` : ""}`,
        )
      }

      const outputResult = await hook(END, {
        module,
        content,
        output: output.join("\n\n"),
      })

      return {
        status: "success",
        message: "File printed successfully",
        destFile: `${module}${this.documentExtension}`,
        content: outputResult ?? output.join("\n\n"),
      }
    },
  },
]

export const contracts = [
  `
---
accepts:
  root:
    dataType: object
    required: true
    contains:
      functions:
        dataType: object[]
        required: true
        contains:
          name:
            dataType: string
            required: true  # Used in sorting and section headers
          description:
            dataType: string[]  # Optional, handled gracefully if missing
          param:
            dataType: object[]
            contains:
              type:
                dataType: string
                required: true  # Used in param formatting
              name:
                dataType: string
                required: true  # Used in param formatting
              content:
                dataType: string[]
                required: true  # Used for param descriptions
          return:
            dataType: object
            contains:
              type:
                dataType: string
                required: true  # Used in return type display
              content:
                dataType: string[]  # Optional, handled if missing
          example:
            dataType: string[]  # Optional, handled gracefully if missing
`,
]
