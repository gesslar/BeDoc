export const actions = [
  {
    meta: Object.freeze({
      action: "print",
      format: "wikitext",
    }),

    setup({ parent, log }) {
      this.parent = parent
      this.log = log
      this.documentExtension = ".txt"
    },

    /**
     * This is the action to print structured object to text.
     *
     * @param {object} module Data coming in from the printer
     * @param {string} module.moduleName The module name (base name) of the
     *  file
     * @param {object[]} module.moduleContent An array of objects containing
     *  function definitions.
     * @returns {Promise<object>} The result of the print operations.
     */
    async run(module) {
      const hook = this.hook ?? (async () => null)
      const debug = this.log.newDebug()
      const { START, SECTION_LOAD, ENTER, EXIT, END } = this.HOOKS ?? {}

      const { file: { module: moduleName }, moduleContent } =
        await hook(START, module) ?? module

      debug("Printing module", 3, moduleName)

      const sorted =
        moduleContent?.sort(function (a, b) {
          return a.name?.localeCompare(b.name)
        }) ?? module.moduleContent

      if (sorted === undefined || sorted.length === 0)
        return {
          status: "warning",
          warning: `No functions to print for module: \`${moduleName}\``
        }

      const moduleOutput = []

      /**
       * Generic section printer
       *
       * @param {string} sectionName - The section name
       * @param {object} sectionContent - The function section to process
       * @param {Function} formatContent - Callback to format the content
       * @returns {Promise<string>} The formatted content
       */
      async function printIt(sectionName, sectionContent, formatContent) {
        // If we don't even have anything, nevermind? lulz
        if (!sectionContent)
          return null

        // ENTER - should return the exactly same shaped object as was passed
        // to it.
        const enter = await hook(ENTER, { moduleName, sectionName, sectionContent })

        // Whew, that was a lot of work far! We should now get a string result.
        const formatted = formatContent(enter?.sectionContent || sectionContent)

        // EXIT - should take the string so far, and return even more string.
        // Well, not _MORE_ string, but... shut up.
        const exit = await hook(
          EXIT, {
          moduleName,
          sectionName,
          sectionContent: formatted
        }
        ) ?? formatted

        return exit
      }

      for (const section of sorted) {
        const work = await hook(SECTION_LOAD, { moduleName, section })
          ?? section

        let output, sectionName
        const sectionOutput = new Map()

        // 1. Print the section name - this one is special since it
        //    is actually part of the signature section
        sectionName = "name"
        output = await printIt(sectionName, section.signature.name, w => {
          return `== ${w} ==`
        })
        output && sectionOutput.set(sectionName, output)

        // 2. Handle any deprecation notices
        sectionName = "deprecated"
        output = await printIt(sectionName, work[sectionName], w => {
          return `{{Admonition|type=stop|title=Deprecated|${w.map(c => c.trim()).join(" ")}}}`
        })
        output && sectionOutput.set(sectionName, output)

        // 2. Print the signature
        sectionName = "signature"
        output = await printIt(sectionName, work[sectionName], w => {
          return `<code>${w.access} ` +
            `${w.modifiers.length ? w.modifiers.join(" ") + " " : ""}` +
            `''${w.type}'' '''${w.name}'''` +
            `(${w.parameters.join(", ")})` +
            `</code>`
        })
        output && sectionOutput.set(sectionName, output)

        // 3. Print the section description
        sectionName = "description"
        output = await printIt(sectionName, work[sectionName], w => {
          return w.length ? w.map(line => line.trim()).join("\n") : ""
        })
        output && sectionOutput.set(sectionName, output)

        // 3. Print the section parameters
        sectionName = "param"
        output = await printIt(sectionName, work[sectionName], w => {
          const params = w.map(p => {

            // capture detailed name info
            let optionalParam, paramName, defaultValue

            // Determine if this is an optional parameter
            const optionalMatch = p.name.match(/^\[(.*)\]$/)
            if (optionalMatch) {
              optionalParam = true
              paramName = optionalMatch[1]
            } else {
              paramName = p.name
            }

            // Determine if there is a default value
            const defaultMatch = paramName.match(/(.*)=(.*)/)
            defaultValue = defaultMatch ? defaultMatch[2] : null
            paramName = defaultMatch ? defaultMatch[1] : paramName

            let optionalAndOrDefault = optionalParam || defaultValue
              ? (() => {
                if (optionalParam && defaultValue)
                  return ` (Optional. Default: ${defaultValue})`
                else if (optionalParam)
                  return " (Optional)"
                else if (defaultValue)
                  return ` (Default: ${defaultValue})`
                else
                  throw new Error("Uhm, we seem to have hit a bump.")
              })()
              : ""

            const content = p.content
            while (content.length && (!content.at(0) || !content.at(-1))) {
              if (!content.at(0))
                content.shift()

              if (!content.at(-1))
                content.pop()
            }

            return `;'''${paramName}''' ''${p.type}${optionalAndOrDefault}''\n` +
              `:${content.map(c => c.trim()).join(" ")}`
          }) ?? []
          return params.join("\n")
        })
        output && sectionOutput.set(sectionName, output)

        // 4. Print the section return
        sectionName = "return"
        output = await printIt(sectionName, work[sectionName], w => {
          const ret = w

          return ret
            ? `=== Returns ===\n\n''<code>${ret.type}</code>'' ` +
            `${ret.content?.map(c => c.trim()).join(" ") ?? ""}`
            : ""
        })
        output && sectionOutput.set(sectionName, output)

        // 5. Print the section example
        sectionName = "example"
        output = await printIt(sectionName, work[sectionName], w => w.length
          ? "=== Example ===\n\n" + w.join("\n")
          : ""
        )
        output && sectionOutput.set(sectionName, output)
        moduleOutput.push(Array.from(sectionOutput.values()).join("\n\n"))
      }

      debug(`Printing complete for module \`${moduleName}\``, 3)

      const joinedOutput = moduleOutput.join("\n")
      const finalOutput = await hook(
        END, {
        moduleName,
        moduleContent: joinedOutput
      }
      ) ?? joinedOutput

      return {
        status: "success",
        message: "File printed successfully",
        destFile: `${moduleName}${this.documentExtension}`,
        destContent: finalOutput,
      }
    },
  },
]

export const contracts = [
  `
accepts:
  type: object
  required:
    - functions
  properties:
    functions:
      type: array
      items:
        type: object
        required:
          - name
          - return
        properties:
          name:
            type: string
          description:
            type: array
            items:
              type: string
          param:
            type: array
            items:
              type: object
              required:
                - type
                - name
              properties:
                type:
                  oneOf:
                    - type: string
                    - type: array
                      items:
                        type: string
                name:
                  type: string
                content:
                  type: array
                  items:
                    type: string
          return:
            type: object
            required:
              - type
            properties:
              type:
                oneOf:
                  - type: string
                  - type: array
                    items:
                      type: string
              content:
                type: array
                items:
                  type: string
          example:
            type: array
            items:
              type: string
`,
]
