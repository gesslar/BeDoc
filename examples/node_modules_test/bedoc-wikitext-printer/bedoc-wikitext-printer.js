export const actions = [
  {
    meta: Object.freeze({
      action: "print",
      format: "wikitext",
    }),

    setup({parent, log}) {
      this.parent = parent
      this.log = log
      this.documentExtension = ".txt"
    },

    async run({module, content}) {
      const debug = this.log.newDebug()
      const hook = this.hook
      const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS ?? {}

      const start = await hook(START, {module, content}) ?? content
      const sorted = start?.functions?.sort((a, b) =>
        a.name.localeCompare(b.name),
      )

      if(!sorted)
        throw new Error("No functions to print")

      const moduleOutput = []

      /**
       * Generic section printer
       *
       * @param {string} name - The section name
       * @param {object} section - The function section to process
       * @param {Function} formatContent - Callback to format the content
       * @returns {Promise<string>} The formatted content
       */
      async function printIt(name, section, formatContent) {
        const enter = await hook(ENTER, {module, section, name}) ?? section
        const formatted = formatContent(enter)
        const exit = await hook(EXIT, {module, name, content: formatted})
        return exit ?? formatted
      }

      for(const section of sorted) {
        const work = await hook(SECTION_LOAD, {section}) ?? section
        let output, sectionName
        const sectionOutput = new Map()

        // 1. Print the section name
        sectionName = "name"
        output = await printIt(sectionName, work, w => `== ${w.name} ==\n`)
        output && sectionOutput.set(sectionName, output)

        // 2. Print the section description
        sectionName = "description"
        output = await printIt(sectionName, work, w =>
          w.description?.length
            ? w.description.map((line) => line.trim()).join("\n")
            : ""
        )
        output && sectionOutput.set(sectionName, output)

        // 3. Print the section parameters
        sectionName = "param"
        output = await printIt(sectionName, work, w => {
          const params = w.param?.map(p => {
            const isOptional = p.content.some(l => l.toLowerCase().includes("(optional)"))
            const content = p.content
              .map(l => l.replace("(optional)", "").trim())
              .join(" ")
              .replace(/\s+/g, " ")
            const optionalTag = p.optional || isOptional ? ", ''optional''" : ""
            return `* <code>''${p.type}'' '''${p.name}'''</code> ${optionalTag} ${content}`
          }) ?? []
          return params.join("\n")
        })
        output && sectionOutput.set(sectionName, output)

        // 4. Print the section return
        sectionName = "return"
        output = await printIt(sectionName, work, w => {
          const ret = w.return
          return ret
            ? `=== Returns ===\n\n''<code>${ret.type}</code>'' ${ret.content ?? ""}\n`
            : ""
        })
        output && sectionOutput.set(sectionName, output)

        // 5. Print the section example
        sectionName = "example"
        output = await printIt(sectionName, work, w =>
          w.example?.length
            ? "=== Example ===\n\n" + w.example.join("\n")
            : ""
        )
        output && sectionOutput.set(sectionName, output)

        moduleOutput.push(Array.from(sectionOutput.values()).join("\n\n"))

        // moduleOutput.push(
        //   `${outputName}` +
        //     `${outputDescription.length ? `\n${outputDescription}\n` : ""}` +
        //     `${outputParams.length ? `\n${outputParams}\n` : ""}` +
        //     `${outputReturns.length ? `\n${outputReturns}\n` : ""}` +
        //     `${outputExample.length ? `\n${outputExample}\n` : ""}`,
        // )
      }

      const outputResult = await hook(END,
        {module, content, output: moduleOutput.join("\n")}
      )

      return {
        status: "success",
        message: "File printed successfully",
        destFile: `${module}${this.documentExtension}`,
        content: outputResult ?? moduleOutput.join("\n"),
      }
    },
  },
]


export const contracts = [
  `
---
accepts:
  root:
    dataType: object
    required: true
    contains:
      functions:
        dataType: object[]
        required: true
        contains:
          name:
            dataType: string
            required: true  # Used in sorting and section headers
          description:
            dataType: string[]  # Optional, handled gracefully if missing
          param:
            dataType: object[]
            contains:
              type:
                dataType: string
                required: true  # Used in param formatting
              name:
                dataType: string
                required: true  # Used in param formatting
              content:
                dataType: string[]
                required: true  # Used for param descriptions
          return:
            dataType: object
            contains:
              type:
                dataType: string
                required: true  # Used in return type display
              content:
                dataType: string[]  # Optional, handled if missing
          example:
            dataType: string[]  # Optional, handled gracefully if missing
`,
]
