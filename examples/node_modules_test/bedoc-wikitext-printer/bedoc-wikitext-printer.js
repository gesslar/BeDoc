/**
 * @file Wikitext Printer - A printer for converting structured documentation
 * data into Wikitext format.
 *
 * This printer takes parsed documentation objects (functions with descriptions,
 * parameters, return types, and examples) and formats them as readable
 * Wikitext output.
 *
 * The printer uses a pipeline approach defined via ActionBuilder and
 * integrates with the BeDoc documentation system.
 *
 * @author gesslar
 * @version 1.0.0
 * @since 1.0.0
 */

import {ActionBuilder, ACTIVITY} from "@gesslar/actioneer"
import {Promised} from "@gesslar/toolkit"

/**
 * Wikitext Printer Class - Formats parsed documentation into Wikitext.
 *
 * This printer is designed to work with the structured output from BeDoc
 * parsers, converting function documentation into well-formatted Wikitext
 * files with headers, parameter lists, return types, and examples.
 *
 * @class
 */
export default class WikitextPrinter {
  /**
   * Printer metadata defining its characteristics and contract.
   *
   * @readonly
   * @type {object}
   * @property {string} kind - The type of action.
   * @property {string} format - The format of the file this printer emits.
   * @property {string} extension - The file extension for output files.
   * @property {string} terms - The contract terms file name.
   */
  static meta = Object.freeze({
    kind: "print",
    format: "wikitext",
    extension: "txt",
    terms: "ref://./bedoc-wikitext-printer.yaml"
  })

  /**
   * Configures the printer using ActionBuilder's fluent API.
   *
   * This method sets up the printing pipeline:
   * - Prepare and sort functions
   * - Format each function into Wikitext sections (via SPLIT)
   * - Finalize by joining all sections into the output
   *
   * @param {ActionBuilder} builder - The ActionBuilder instance to configure
   * @returns {ActionBuilder} The configured builder instance
   */
  setup = builder => builder
    .do("Format functions", ACTIVITY.SPLIT,
      ctx => ctx, // splitter. just bare, nothing to do here.
      this.#rejoinFormatted, // rejoiner
      new ActionBuilder()
        .do("Format function", this.#formatFunction)
    )
    .done(this.#finalize)

  /**
   * Formats a single function's documentation into Wikitext.
   *
   * Processes each section of a function (name, deprecated, signature,
   * description, parameters, return type, and examples) into formatted
   * Wikitext.
   *
   * @param {object} ctx - A parsed function object
   * @param {string} ctx.name - The function name
   * @param {Array<string>} [ctx.deprecated] - Deprecation notice lines
   * @param {object} [ctx.signature] - Signature definition
   * @param {Array<string>} [ctx.description] - Description lines
   * @param {Array<object>} [ctx.param] - Parameter definitions
   * @param {object} [ctx.return] - Return type info
   * @param {Array<string>} [ctx.example] - Example lines
   * @returns {object} The ctx with a `formatted` array of Wikitext sections
   * @private
   */
  #formatFunction = ctx => {
    const sections = []

    // 1. Print the function name
    if(ctx.name)
      sections.push(`== ${ctx.name} ==`)

    // 2. Handle any deprecation notices
    if(ctx.deprecated?.length)
      sections.push(`{{Admonition|type=stop|title=Deprecated|${ctx.deprecated.map(c => c.trim()).join(" ")}}}`)

    // 3. Print the signature
    if(ctx.signature) {
      const sig = ctx.signature
      const signature = [
        sig.access ?? "",
        sig.modifier1 ?? "",
        sig.modifier2 ?? "",
        sig.type ? `''${sig.type}''` : "",
        sig.name ? `'''${sig.name}'''` : "",
        sig.parms ? `(${sig.parms})` : "()"
      ].filter(Boolean)

      if(signature.length)
        sections.push(`<code>${signature.join(" ")}</code>`)
    }

    // 4. Print the description
    if(ctx.description?.length) {
      const formatted = ctx.description.map(line => line.trim()).join("\n").trim()
      sections.push(formatted)
    }

    // 5. Print the parameters
    if(ctx.param?.length) {
      const params = ctx.param.map(p => {
        let paramName = p.name
        let optional = false
        let defaultValue = null

        // Determine if this is an optional parameter
        const optionalMatch = paramName.match(/^\[(.*)\]$/)
        if(optionalMatch) {
          optional = true
          paramName = optionalMatch[1]
        }

        // Determine if there is a default value
        const defaultMatch = paramName.match(/(.*)=(.*)/)
        if(defaultMatch) {
          paramName = defaultMatch[1]
          defaultValue = defaultMatch[2]
        }

        const optionalAndOrDefault = optional || defaultValue
          ? (() => {
            if(optional && defaultValue)
              return ` (Optional. Default: ${defaultValue})`
            else if(optional)
              return " (Optional)"
            else if(defaultValue)
              return ` (Default: ${defaultValue})`
            else
              throw new Error("Uhm, we seem to have hit a bump.")
          })()
          : ""

        const content = [...(p.content ?? [])]
        while(content.length && (!content.at(0) || !content.at(-1))) {
          if(!content.at(0))
            content.shift()

          if(!content.at(-1))
            content.pop()
        }

        return `;'''${paramName}''' ''${p.type}${optionalAndOrDefault}''\n` +
          `:${content.map(c => c.trim()).join(" ")}`
      })

      sections.push(params.join("\n"))
    }

    // 6. Print the return type
    if(ctx.return) {
      const r = ctx.return
      sections.push(`=== Returns ===\n\n''<code>${r.type}</code>'' ` +
        `${r.content?.map(c => c.trim()).join(" ") ?? ""}`)
    }

    // 7. Print the examples
    if(ctx.example?.length)
      sections.push("=== Example ===\n\n" + ctx.example.join("\n"))

    return Object.assign({}, {...ctx, formatted: sections})
  }

  #rejoinFormatted(_, settled) {
    if(Promised.hasRejected(settled))
      Promised.throw(settled)

    const values = Promised.values(settled)
    const formatted = values.map(e => e.formatted)

    formatted.push("") // blank line between functions

    return formatted
  }

  /**
   * Final processing method called after all formatting is complete.
   *
   * Joins the formatted function sections into a single Wikitext document.
   *
   * @param {Array<string>} ctx - Array of formatted Wikitext strings
   * @returns {string} The complete Wikitext output
   * @private
   */
  #finalize = ctx => {
    return ctx.flat().join("\n\n")
  }
}
