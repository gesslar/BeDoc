/**
 * The meta information for this printer.
 */
const meta = Object.freeze({
  // Printer information
  format: "wikitext",
  formatExtension: ".txt",
});

class Printer {
  constructor(core) {
    this.core = core
    this.string = core.string
    this.logger = core.logger
  }

  /**
   * @param {string} module - The module name to print.
   * @param {object} content - The content to be printed.
   * @returns {Promise<object>} The result of the print operation.
   */
  async print(module, content) {
    const hook = this.hook.bind(this)
    const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS.print

    await hook(START, {module, content})

    const work = content.functions.sort((a, b) => a.name.localeCompare(b.name))
    const output = []

    const printName = async section => {
      await hook(ENTER, {name:"name", section, meta})
      const outputName = `== ${section.name} ==\n`
      const outputResult = await hook(EXIT, {name:"name", content: outputName, meta})
      return outputResult ?? outputName
    }

    const printDescription = async section => {
      this.logger.debug(`[printDescription] section: ${JSON.stringify(section, null, 1)}`, 4)
      await hook(ENTER, {name:"description", section, meta})
      const outputDescription = section.description?.length
        ? section.description.map(line => line.trim()).join("\n")
        : ""
      const outputResult = await hook(EXIT, {name:"description", content: outputDescription, meta})
      return outputResult ?? outputDescription
    }

    const printParams = async section => {
      await hook(ENTER, {name:"param", section, meta})
      const outputParams = []

      if(!section.param)
        return outputParams

      for(const param of section.param || []) {
        const isOptional = param.content.some(line => line.toLowerCase().includes("(optional)"))
        const content = param.content
          .map(line => line.replace("(optional)", "").trim())
          .join(" ") // Flatten multiline descriptions into one line
          .replace(/\s+/g, " ") // Ensure clean spacing

        const optionalTag = param.optional || isOptional ? ", ''optional''" : ""
        const result =
          `* '''<code>${param.name}</code>''' (<code>${param.type}</code>${optionalTag}): ${content}`
        outputParams.push(result)
      }
      const outputResult = await hook(EXIT, {name:"param", content: outputParams, meta})
      return outputResult ?? outputParams
    }

    const printReturns = async section => {
      await hook(ENTER, {name:"return", section, meta})
      // Then the returns
      const outputReturns = section.return
        ? `=== Returns ===\n\n${
          section.return.content
            ? `'''<code>${section.return.type}</code>''': ${section.return.content}`
            : `'''<code>${section.return.type}</code>'''`
        }`
        : ""

      const outputResult = await hook(EXIT, {name:"return", content: outputReturns, meta})
      return outputResult ?? outputReturns
    }

    const printExample = async section => {
      await hook(ENTER, {name:"example", section, meta})
      const outputExample = section.example?.length
        ? "== Example ==\n\n" + section.example.join("\n")
        : ""
      const outputResult = await hook(EXIT, {name:"example", content: outputExample, meta})
      return outputResult ?? outputExample
    }

    for(const section of work) {
      await this.hook(SECTION_LOAD, {section, meta})

      // First the function name
      const outputName = await printName(section)

      // Then the description
      const outputDescription = await printDescription(section)

      // Then the parameters
      const outputParams = await printParams(section)

      // Then the returns
      const outputReturns = await printReturns(section)

      // Then the example
      const outputExample = await printExample(section)

      output.push(`${outputName}` +
        `${outputDescription.length ? `\n${outputDescription}\n` : ""}` +
        `${outputParams.length ? `\n${outputParams.join("\n")}\n` : ""}` +
        `${outputReturns.length ? `\n${outputReturns}\n` : ""}` +
        `${outputExample.length ? `\n${outputExample}\n` : ""}`)
    }

    const outputResult = await hook(END, {module, content, output})

    return {
      status: 'success',
      message: 'File printed successfully',
      destFile: `${module}${meta.formatExtension}`,
      content: outputResult ?? output.join('\n\n'),
    };
  }
};

export { meta, Printer }
