export const actions = [
  {
    meta: Object.freeze({
      action: "print",
      format: "markdown",
    }),

    init(config) {
      this.parent = config.parent
      this.log = config.log
      this.documentExtension = ".md"
    },

    /**
     * Print the results to a buffer and return it to BeDoc for writing
     * @param {string} module - The module name to print.
     * @param {object} content - The content to be printed.
     * @returns {Promise<object>} The result of the print operation.
     */
    async print(module, content) {
      const debug = this.log.newDebug()
      const hook = this.hook
      const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS

      await hook(START, {module, content})

      const work = content.functions.sort((a, b) =>
        a.name.localeCompare(b.name),
      )
      const output = []

      const printName = async(section) => {
        await hook(ENTER, {name: "name", section})
        const outputName = `## ${section.name}`
        const outputResult = await hook(EXIT, {
          name: "name",
          content: outputName,
        })
        return outputResult ?? outputName
      }

      const printDescription = async(section) => {
        debug(
          `[printDescription] section: ${JSON.stringify(section, null, 1)}`,
          4,
        )
        await hook(ENTER, {name: "description", section})
        const outputDescription = section.description?.length
          ? this.wrap(section.description.map((line) => line.trim()).join("\n"))
          : ""
        const outputResult = await hook(EXIT, {
          name: "description",
          content: outputDescription,
        })
        return outputResult ?? outputDescription
      }

      const printParams = async(section) => {
        await hook(ENTER, {name: "param", section})
        const outputParams = []

        if(!section.param) return outputParams

        for(const param of section.param || []) {
          const isOptional = param.content.some((line) =>
            line.toLowerCase().includes("(optional)"),
          )
          const content = param.content
            .map((line) => line.replace("(optional)", "").trim()) // Fixes issue #11
            .join(" ") // Flatten multiline descriptions into one line
            .replace(/\s+/g, " ") // Ensure clean spacing

          const optionalTag =
            param.optional || isOptional ? ", *optional*" : ""
          const result = this.wrap(
            `- **\`${param.name}\`** (\`${param.type}\`${optionalTag}): ${content}`,
            undefined,
            2,
          )
          outputParams.push(result)
        }
        const outputResult = await hook(EXIT, {
          name: "param",
          content: outputParams,
        })
        return outputResult ?? outputParams
      }

      const printReturns = async(section) => {
        await hook(ENTER, {name: "return", section})

        // Then the returns
        const outputReturns = section.return
          ? `### Returns\n\n${this.wrap(
            section.return.content
              ? `- **\`${section.return.type}\`**: ${section.return.content}`
              : `- **\`${section.return.type}\`**`,
            undefined,
            2,
          )}`
          : ""

        const outputResult = await hook(EXIT, {
          name: "return",
          content: outputReturns,
        })
        return outputResult ?? outputReturns
      }

      const printExample = async(section) => {
        await hook(ENTER, {name: "example", section})
        const outputExample = section.example?.length
          ? "### Example\n\n" + this.wrap(section.example.join("\n"))
          : ""
        const outputResult = await hook(EXIT, {
          name: "example",
          content: outputExample,
        })
        return outputResult ?? outputExample
      }

      for(const section of work) {
        await hook(SECTION_LOAD, {section})

        // First the function name
        const outputName = await printName(section)

        // Then the description
        const outputDescription = await printDescription(section)

        // Then the parameters
        const outputParams = await printParams(section)

        // Then the returns
        const outputReturns = await printReturns(section)

        // Then the example
        const outputExample = await printExample(section)

        output.push(
          `${outputName}` +
            `${outputDescription.length ? `\n${outputDescription}\n` : ""}` +
            `${outputParams.length ? `\n${outputParams.join("\n")}\n` : ""}` +
            `${outputReturns.length ? `\n${outputReturns}\n` : ""}` +
            `${outputExample.length ? `\n${outputExample}\n` : ""}`,
        )
      }

      const outputResult = await hook(END, {module, content, output})

      return {
        status: "success",
        message: "File printed successfully",
        destFile: `${module}${this.documentExtension}`,
        content: outputResult ?? output.join("\n"),
      }
    },

    /**
     * Wraps text to a specified width with optional indentation
     * @param {string} str - The text to wrap
     * @param {number} [wrapAt] - The column at which to wrap the text
     * @param {number} [indentAt] - The number of spaces to indent wrapped lines
     * @returns {string} The wrapped text
     */
    wrap(str, wrapAt = 80, indentAt = 0) {
      const sections = str.split("\n").map((section) => {
        let parts = section.split(" ")
        let inCodeBlock = false
        let isStartOfLine = true // Start of each section is start of line

        // Preserve leading space if it existed
        if(section[0] === " ") {
          parts = ["", ...parts]
        }

        let running = 0

        parts = parts.map((part) => {
          // Only check for code block if we're at start of line
          if(isStartOfLine && /^```(?:\w+)?$/.test(part)) {
            inCodeBlock = !inCodeBlock
            running += part.length + 1
            isStartOfLine = false
            return part
          }

          if(part[0] === "\n") {
            running = 0
            isStartOfLine = true // Next part will be at start of line
            return part
          }

          running += part.length + 1
          isStartOfLine = false // No longer at start of line

          if(!inCodeBlock && running >= wrapAt) {
            running = part.length + indentAt
            isStartOfLine = true // After newline, next part will be at start
            return "\n" + " ".repeat(indentAt) + part
          }

          return part
        })

        return parts
          .join(" ")
          .split("\n")
          .map((line) => line.trimEnd())
          .join("\n")
      })

      return sections.join("\n")
    },
  },
]

export const contracts = [
  `
---
accepts:
  root:
    dataType: object
    required: true
    contains:
      functions:
        dataType: object[]
        required: true
        contains:
          name:
            dataType: string
            required: true  # Used in sorting and section headers
          description:
            dataType: string[]  # Optional, handled gracefully if missing
          param:
            dataType: object[]
            contains:
              type:
                dataType: string|string[]
                required: true  # Used in param formatting
              name:
                dataType: string
                required: true  # Used in param formatting
              content:
                dataType: string[]
                required: true  # Used for param descriptions
          return:
            dataType: object
            contains:
              type:
                dataType: string|string[]
                required: true  # Used in return type display
              content:
                dataType: string[]  # Optional, handled if missing
          example:
            dataType: string[]  # Optional, handled gracefully if missing
`,
]
