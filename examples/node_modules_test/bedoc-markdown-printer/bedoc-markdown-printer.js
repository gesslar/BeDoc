export const actions = [
  {
    meta: Object.freeze({
      action: "print",
      format: "markdown",
    }),

    setup({parent,log}) {
      this.parent = parent
      this.log = log
      this.documentExtension = ".md"
    },

    /**
     * Print the results to a buffer and return it to BeDoc for writing
     *
     * @param {{[key: string]: object}} data - The content to be printed.
     * @returns {Promise<object>} The result of the print operation.
     */
    async run({module, content}) {
      const hook = this.hook
      const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS ?? {}

      const start = await hook(START, {module, content}) ?? content
      const sorted = start?.functions?.sort((a, b) =>
        a.name.localeCompare(b.name),
      )

      if(!sorted)
        throw new Error("No functions to print")

      const moduleOutput = []

      /**
       * Generic section printer
       *
       * @param {string} name - The section name
       * @param {object} section - The function section to process
       * @param {Function} formatContent - Callback to format the content
       * @returns {Promise<string>} The formatted content
       */
      async function printIt(name, section, formatContent) {
        const enter = await hook(ENTER, {module, section, name}) ?? section
        const formatted = formatContent(enter)
        const exit = await hook(EXIT, {module, name, content: formatted})
        return exit ?? formatted
      }

      for(const section of sorted) {
        const work = await hook(SECTION_LOAD, {section}) ?? section
        let output, sectionName
        const sectionOutput = new Map()

        // 1. Print the section name
        sectionName = "name"
        output = await printIt(sectionName, work, w => `## ${w.name}`)
        output && sectionOutput.set(sectionName, output)

        // 2. Print the section description
        sectionName = "description"
        output = await printIt(sectionName, work, w => w.description?.length
          ? w.description.map(line => line.trim()).join("\n")
          : "")
        output && sectionOutput.set(sectionName, output)

        // 3. Print the section parameters
        sectionName = "param"
        output = await printIt(sectionName, work, w => {
          const outputParams = []

          if(!w.param)
            return outputParams

          for(const param of w.param || []) {
            const isOptional = param.content.some(line =>
              line.toLowerCase().includes("(optional)"),
            )
            const content = param.content
              .map(line => line.replace("(optional)", "").trim()) // Fixes issue #11
              .join(" ") // Flatten multiline descriptions into one line
              .replace(/\s+/g, " ") // Ensure clean spacing

            const optionalTag =
              param.optional || isOptional ? ", *optional*" : ""
            const result = `- **\`${param.name}\`** (\`${param.type}\`${optionalTag}): ${content}`
            outputParams.push(result)
          }

          return outputParams
        })
        output && sectionOutput.set(sectionName, output.join("\n"))

        // 4. Print the section return
        sectionName = "return"
        output = await printIt(sectionName, work, w => w.return
          ? `### Returns\n\n${w.return.content
            ? `- **\`${w.return.type}\`**: ${w.return.content}`
            : `- **\`${w.return.type}\`**`}`
          : "")
        output && sectionOutput.set(sectionName, output)

        // 5. Print the section example
        sectionName = "example"
        output = await printIt(sectionName, work, w => w.example?.length
          ? "### Example\n\n" + w.example.join("\n")
          : "")
        output && sectionOutput.set(sectionName, output)

        moduleOutput.push(Array.from(sectionOutput.values()).join("\n\n")+ "\n")
      }

      const outputResult = await hook(END,
        {module, content, output: moduleOutput}
      )

      return {
        status: "success",
        message: "File printed successfully",
        destFile: `${module}${this.documentExtension}`,
        content: outputResult ?? moduleOutput.join("\n"),
      }
    },

    /**
     * Wraps text to a specified width with optional indentation
     *
     * @param {string} str - The text to wrap
     * @param {number} [wrapAt] - The column at which to wrap the text
     * @param {number} [indentAt] - The number of spaces to indent wrapped lines
     * @returns {string} The wrapped text
     */
    wrap(str, wrapAt = 80, indentAt = 0) {
      const sections = str.split("\n").map(section => {
        let parts = section.split(" ")
        let inCodeBlock = false
        let isStartOfLine = true // Start of each section is start of line

        // Preserve leading space if it existed
        if(section[0] === " ")
          parts = ["", ...parts]

        let running = 0

        parts = parts.map(part => {
          // Only check for code block if we're at start of line
          if(isStartOfLine && /^```(?:\w+)?$/.test(part)) {
            inCodeBlock = !inCodeBlock
            running += part.length + 1
            isStartOfLine = false
            return part
          }

          if(part[0] === "\n") {
            running = 0
            isStartOfLine = true // Next part will be at start of line
            return part
          }

          running += part.length + 1
          isStartOfLine = false // No longer at start of line

          if(!inCodeBlock && running >= wrapAt) {
            running = part.length + indentAt
            isStartOfLine = true // After newline, next part will be at start
            return "\n" + " ".repeat(indentAt) + part
          }

          return part
        })

        return parts
          .join(" ")
          .split("\n")
          .map(line => line.trimEnd())
          .join("\n")
      })

      return sections.join("\n")
    },
  },
]

export const contracts = [
  `
---
accepts:
  root:
    dataType: object
    required: true
    contains:
      functions:
        dataType: object[]
        required: true
        contains:
          name:
            dataType: string
            required: true  # Used in sorting and section headers
          description:
            dataType: string[]  # Optional, handled gracefully if missing
          param:
            dataType: object[]
            contains:
              type:
                dataType: string|string[]
                required: true  # Used in param formatting
              name:
                dataType: string
                required: true  # Used in param formatting
              content:
                dataType: string[]
                required: true  # Used for param descriptions
          return:
            dataType: object
            contains:
              type:
                dataType: string|string[]
                required: true  # Used in return type display
              content:
                dataType: string[]  # Optional, handled if missing
          example:
            dataType: string[]  # Optional, handled gracefully if missing
`,
]
