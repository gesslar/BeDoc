/**
 * The meta information for this printer.
 */
const meta = Object.freeze({
  format: "markdown",
  formatExtension: ".md",
})

class Printer {
  constructor(core) {
    this.core = core
    this.string = core.string
    this.logger = core.logger
  }

  /**
   * Print the results to a buffer and return it to BeDoc for writing
   * @param {string} module - The module name to print.
   * @param {object} content - The content to be printed.
   * @returns {Promise<object>} The result of the print operation.
   */
  async print(module, content) {
    const hook = this.hook || (async() => {})
    const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS?.print ?? {}

    // console.log("content", content)
    await hook(START, {module, content})

    const work = content.functions.sort((a, b) => a.name.localeCompare(b.name))
    const output = []

    const printName = async section => {
      await hook(ENTER, {name: "name", section, meta})
      const outputName = `## ${section.name}`
      const outputResult = await hook(EXIT, {name: "name", content: outputName, meta})
      return outputResult ?? outputName
    }

    const printDescription = async section => {
      this.logger.debug(`[printDescription] section: ${JSON.stringify(section, null, 1)}`, 4)
      await hook(ENTER, {name: "description", section, meta})
      const outputDescription = section.description?.length
        ? this.string.wrap(section.description.map(line => line.trim()).join("\n"))
        : ""
      const outputResult = await hook(EXIT, {name: "description", content: outputDescription, meta})
      return outputResult ?? outputDescription
    }

    const printParams = async section => {
      await hook(ENTER, {name: "param", section, meta})
      const outputParams = []

      if(!section.param)
        return outputParams

      for(const param of section.param || []) {
        const isOptional = param.content.some(line => line.toLowerCase().includes("(optional)"))
        const content = param.content
          .map(line => line.replace("(optional)", "").trim()) // Fixes issue #11
          .join(" ") // Flatten multiline descriptions into one line
          .replace(/\s+/g, " ") // Ensure clean spacing

        const optionalTag = param.optional || isOptional ? ", *optional*" : ""
        const result = this.string.wrap(
          `- **\`${param.name}\`** (\`${param.type}\`${optionalTag}): ${content}`,
          undefined,
          2
        )
        outputParams.push(result)
      }
      const outputResult = await hook(EXIT, {name: "param", content: outputParams, meta})
      return outputResult ?? outputParams
    }

    const printReturns = async section => {
      await hook(ENTER, {name: "return", section, meta})

      // Then the returns
      const outputReturns = section.return
        ? `### Returns\n\n${this.string.wrap(
          section.return.content
            ? `- **\`${section.return.type}\`**: ${section.return.content}`
            : `- **\`${section.return.type}\`**`,
          undefined,
          2
        )}`
        : ""

      const outputResult = await hook(EXIT, {name: "return", content: outputReturns, meta})
      return outputResult ?? outputReturns
    }

    const printExample = async section => {
      await hook(ENTER, {name: "example", section, meta})
      const outputExample = section.example?.length
        ? "### Example\n\n" + this.string.wrap(section.example.join("\n"))
        : ""
      const outputResult = await hook(EXIT, {name: "example", content: outputExample, meta})
      return outputResult ?? outputExample
    }

    for(const section of work) {
      await hook(SECTION_LOAD, {section, meta})

      // First the function name
      const outputName = await printName(section)

      // Then the description
      const outputDescription = await printDescription(section)

      // Then the parameters
      const outputParams = await printParams(section)

      // Then the returns
      const outputReturns = await printReturns(section)

      // Then the example
      const outputExample = await printExample(section)

      output.push(`${outputName}` +
        `${outputDescription.length ? `\n${outputDescription}\n` : ""}` +
        `${outputParams.length ? `\n${outputParams.join("\n")}\n` : ""}` +
        `${outputReturns.length ? `\n${outputReturns}\n` : ""}` +
        `${outputExample.length ? `\n${outputExample}\n` : ""}`)
    }

    const outputResult = await hook(END, {module, content, output})

    return {
      status: "success",
      message: "File printed successfully",
      destFile: `${module}${meta.formatExtension}`,
      content: outputResult ?? output.join("\n"),
    }
  }
};

export { meta, Printer }
