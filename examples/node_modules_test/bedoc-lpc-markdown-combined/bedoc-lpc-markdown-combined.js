export const actions = [
  {
    meta: Object.freeze({
      action: "parse",
      language: "lpc",
    }),

    patterns: {
      commentStart: /^\s*\/\*\*(.*)$/, // Match start of a docblock
      commentEnd: /^\s*\*\/\s*$/, // Match end of a docblock
      commentContinuation: /^\s*\*\s?(?<content>.*)$/, // Match continuation of a docblock
      functionPattern: /^\s*(?<access>public|protected|private)?\s*(?<modifier1>nomask|varargs)?\s*(?<modifier2>nomask|varargs)?\s*(?<type>(int|float|void|string|object|mixed|mapping|array|buffer|function)\s*\*?)\s*(?<name>[a-zA-Z_][a-zA-Z0-9_]*)\s*\((?<parms>.*)\)\s*\{?.*$/,
      blankLine: /^\s*$/, // Match blank lines
      argArray: /\w+(\s*\[\s *\]\s *)?/,
      tagContent: /^\{(?<type>\w+(?:\|\w+)*(?:\*)?)\}\s+(?<name>(\w+(\.\w?)*=?\w*\s*(?<rest>\.{3})?|\[\w+=?.*]))(?:\s+-)?\s+(?<content>.*)$/,
      returnContent: /^\{(?<type>[^}]*)\}(?:\s+(?:-\s+)?(?<content>.*))?$/,
    },

    tags: {
      all: [
        "brief", "description", "param", "returns?", "example",
        "meta", "name", "deprecated",
      ],
      singletons: ["name", "return", "example", "meta", "deprecated"],
      convert: {returns: "return"},
      normalize: tag => this.tags.convert[tag] || tag,
      isTagValid(tag) {
        const tags = this.tags
        return [
          ...tags.all,
          ...Object.keys(tags.convert),
          ...Object.values(tags.convert),
        ].includes(tag)
      },
    },

    resetState(full = false) {
      if(full === true)
        this.processing = false

      this.processingComment = false
      this.currentTag = null
    },

    async setup({parent, log}) {
      this.parent = parent
      this.log = log
      this.resetState()
      this.regex = {
        ...this.patterns,
        tag: new RegExp(
          `^\\s*\\*\\s+@(?<tag>${[...this.tags.all].join("|")})\\s?(?<content>.*)$`,
        ),
      }
    },

    /**
     * Parse the content of an LPC file and send it to BeDoc
     *
     * @param {object} module The file name to parse.
     * @param {string} module.file The file object representing the current
     *  being processed
     * @param {object} module.moduleContent The content of the file to parse.
     * @returns {object} The result of the parse operation.
     */
    async run(module) {
      const {file: {module: moduleName}, moduleContent} = module

      const _debug = this.log.newDebug()
      const _hook = this.hook ?? (async() => null)

      this.resetState()
      const result = []

      const lines = moduleContent.split(/\r?\n/)
      let func = null
      let position = 0
      const length = lines.length

      for(; position < length; position++) {
        const line = lines[position]
        const lineTrimmed = line.trim()

        // Skip empty lines unless we're processing a comment
        if(!this.processingComment && !lineTrimmed.length) {
          continue
          // Check for start of doc comment block
        } else if(this.isCommentStart(lineTrimmed)) {
          // Restart with a new function
          func = this.newFunction()
        } else if(this.isCommentEnd(lineTrimmed)) {
          this.resetState()
          continue
        } else if(this.isFunctionLine(lineTrimmed)) {
          const {status, signature} =
            this.extractFunctionSignature(lineTrimmed)

          this.resetState(true)
          if(status === "success") {
            // Only do this if we actually have any content, tho
            if(Object.keys(func ?? {}).length > 0)
              result.push({...func, signature})
            else
              continue
          } else {
            return {
              status: "error",
              file: moduleName,
              line,
              lineNumber: position + 1,
              error: new Error("Problem determining function name.")
            }
          }

          continue
        } else if(this.processingComment) {
          const processed = this.processLine({
            line,
            func,
            file: moduleName,
            position
          })

          const {status,error} = processed
          if(status === "error")
            return {
              status,
              file: moduleName,
              line,
              lineNumber: position + 1,
              error: error
            }
        }
      }

      return {status: "success", result}
    },

    /**
     * Determines if a line is a comment start.
     *
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is the start of a comment.
     */
    isCommentStart(line) {
      // Only consider it a new doc block start if we're not already in a
      // comment, or not processing at all.
      return !this.processing &&
             !this.processingComment &&
             this.regex.commentStart.test(line)
    },

    /**
     * Determines if a line is a comment end.
     *
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is the end of a comment.
     */
    isCommentEnd(line) {
      return this.processing &&
             this.processingComment &&
             this.regex.commentEnd.test(line)
    },

    /**
     * Create a new function object.
     *
     * @returns {object} A new function object.
     */
    newFunction() {
      this.resetState()
      this.processing = true
      this.processingComment = true
      return {}
    },

    /**
     * Generate a formatted message.
     *
     * @param {string} message - The message to log.
     * @param {string} funcName - The function name that generated the message.
     * @param {string} file - The file name that generated the message.
     * @param {number} position - The line number in the source file.
     * @param {string} line - The line of code in the source file.
     * @returns {string} The formatted message.
     */
    generateMessage(message, funcName, file, position, line) {
      return `[${funcName}] ${message}: ${file.moduleName}:${position + 1} - ${line}`
    },

    /**
     * Process a line of code.
     *
     * @param {object} params - The parameters for processing the line.
     * @param {string} params.line - The line to process.
     * @param {object} params.func - The function object being processed.
     * @param {string} params.file - The file name being processed.
     * @param {number} params.position - The line number being processed.
     * @returns {object} The result of the line processing.
     */
    processLine({line, func, file, position}) {
      const lineTrimmed = line.trim()
      const msg = this.generateMessage

      if(!func)
        return {
          status: "error",
          error: new Error(msg("No function context", "processLine", file, position, line)),
        }

      const tagMatches = this.regex.tag.exec(line)
      if(tagMatches) {
        const {tag, content} = tagMatches.groups
        const isValid = this.tags.isTagValid.call(this, tag)

        if(!isValid)
          return {
            status: "error",
            error: new Error(msg(`Invalid tag \`${tag}\``, "processLine", file, position, line)),
          }

        const singleton = this.tags.singletons.includes(tag)

        if(singleton) {
          if(func[tag])
            return {
              status: "error",
              error: new Error(msg(`Singleton tag already exists: ${tag}`, "processLine", file, position, line)),
            }

          func[tag] = null
        } else {
          func[tag] = func[tag] || []
        }

        this.currentTag = tag
        this.section = null

        if(tag === "return") {
          this.section = {tag, name: null}
          const tagContentMatches = this.regex.returnContent.exec(content)
          if(tagContentMatches) {
            const {type, content} = tagContentMatches.groups
            if(!type)
              return {
                status: "error",
                error: new Error(msg(`Missing return type: ${tag}`, "processLine", file, position, line)),
              }

            if(!content) {
              return {
                status: "error",
                error: new Error(msg(`Missing return content: ${tag}`, "processLine", file, position, line))
              }
            } else {
              singleton
                ? (func[tag] = {type, content: [content]})
                : func[tag].push({type, content: [content]})
            }
          } else {
            return {
              status: "error",
              error: new Error(msg("Failed to parse return tag", "processLine", file, position, line)),
            }
          }
        } else {
          const tagContentMatches = this.regex.tagContent.exec(content)
          if(tagContentMatches) {
            const {type, name, rest, content} = tagContentMatches.groups
            if(!type)
              return {
                status: "error",
                error: new Error(msg("Missing tag type", "processLine", file, position, line)),
              }

            if(!name)
              return {
                status: "error",
                error: new Error(msg("Missing tag name", "processLine", file, position, line)),
              }

            this.section = {tag, name}
            const result = {
              type,
              name,
              rest: Boolean(rest),
              content: [content]
            }

            singleton ? func[tag] = result : func[tag].push(result)
          } else {
            // This is probably a singleton
            if(this.tags.singletons.includes(tag)) {
              this.section = {tag, name: null}
              func[tag] = []

              // If we have content, we should add it here.
              content && func[tag].push(content)
            } else {
              return {
                status: "error",
                error: new Error(msg("Failed to parse tag", "processLine", file, position, line)),
              }
            }
          }
        }

        return {status: "success", message: "Processed tag"}
      }

      // Process multiline content
      if(this.currentTag) {
        if(this.section?.name) {
          const currentTag = this.currentTag
          const {tag, name} = this.section

          const index = name
            ? func[tag].findIndex(item => item.name === name)
            : null
          const tagMatch = this.regex.commentContinuation.exec(lineTrimmed)

          if(tagMatch && tagMatch.groups?.content) {
            if(index > -1)
              func[currentTag][index].content.push(tagMatch.groups.content)
            else
              func[currentTag].content.push(tagMatch.groups.content)
          } else {
            if(index !== null)
              func[currentTag][index].content.push("")
            else
              func[currentTag].content.push("")
          }
        } else {
          const {tag} = this.section
          const commentMatch = this.regex.commentContinuation.exec(lineTrimmed)
          if(commentMatch && commentMatch.groups?.content) {
            if(func[tag].content)
              func[tag].content.push(commentMatch.groups.content)
            else
              func[tag].push(commentMatch.groups.content)
          } else {
            if(func[tag].content)
              func[tag].content.push("")
            else
              func[tag].push("")
          }
        }

        return {status: "success", message: "Processed tag continuation"}
      }

      // If not a special tag, treat as description
      const descMatch = this.regex.commentContinuation.exec(lineTrimmed)
      if(descMatch && descMatch.groups?.content) {
        func.description = func.description || []
        func.description.push(descMatch.groups.content)
        return {status: "success", message: "Processed description"}
      } else {
        func.description = func.description || []
        func.description.push("")
        return {status: "success", message: "Processed description"}
      }
    },

    /**
     * Determines if a line is a function definition.
     *
     * @param {string} line - The line to check.
     * @returns {boolean} Whether the line is a function definition.
     */
    isFunctionLine(line) {
      return this.processing &&
             !this.processingComment &&
             this.regex.functionPattern.test(line)
    },

    /**
     * Determine the function name from a line.
     *
     * @param {string} line - The line to determine the function name from.
     * @returns {object} The result of the function name determination.
     */
    extractFunctionSignature(line) {
      const match = this.regex.functionPattern.exec(line)

      if(!match?.groups?.name)
        return {
          status: "error",
          error: new Error(`Failed to extract function from line: ${line}`),
        }

      const groups = match.groups
      const signature = {
        name: groups.name,
        access: groups.access ?? "public",
        type: groups.type ?? "void",
        modifiers: [groups.modifier1, groups.modifier2].filter(Boolean),
        parameters: groups.parms?.split(",").map(p => p.trim()) ?? []
      }

      return {status: "success", signature}
    },
  },
  {
    meta: Object.freeze({
      action: "print",
      format: "markdown",
    }),

    setup({parent,log}) {
      this.parent = parent
      this.log = log
      this.documentExtension = ".md"
    },

    /**
     * This is the action to print structured object to text.
     *
     * @param {object} module Data coming in from the printer
     * @param {object} module.file The file object representing the file
     * being currently being processed
     * @param {object[]} module.moduleContent An array of objects containing
     *  function definitions prepared by the parser.
     * @returns {Promise<object>} The result of the print operations.
     */
    async run(module) {
      const hook = this.hook ?? (async() => null)
      const debug = this.log.newDebug()
      const {START, SECTION_LOAD, ENTER, EXIT, END} = this.HOOKS ?? {}

      const {file: {module: moduleName}, moduleContent} =
        await hook(START, module) ?? module

      debug("Printing module", 3, moduleName)

      const sorted =
        moduleContent?.sort(function(a, b) {
          return a.name?.localeCompare(b.name)
        }) ?? module.moduleContent

      if(sorted === undefined || sorted.length === 0)
        return {
          status: "warning",
          warning: `No functions to print for module: \`${moduleName}\``
        }

      const moduleOutput = []

      /**
       * Generic section printer
       *
       * @param {string} sectionName - The section name
       * @param {object} sectionContent - The function section to process
       * @param {Function} formatContent - Callback to format the content
       * @returns {Promise<string>} The formatted content
       */
      async function printIt(sectionName, sectionContent, formatContent) {
        // If we don't even have anything, nevermind? lulz
        if(!sectionContent)
          return null

        // ENTER - should return the exactly same shaped object as was passed
        // to it.
        const enter = await hook(ENTER, {moduleName,sectionName,sectionContent})

        // Whew, that was a lot of work far! We should now get a string result.
        const formatted = formatContent(enter?.sectionContent || sectionContent)

        // EXIT - should take the string so far, and return even more string.
        // Well, not _MORE_ string, but... shut up.
        const exit = await hook(
          EXIT, {
            moduleName,
            sectionName,
            sectionContent: formatted
          }
        ) ?? formatted

        return exit
      }

      for(const section of sorted) {
        const work = await hook(SECTION_LOAD, {moduleName, section})
                           ?? section
        let output, sectionName
        const sectionOutput = new Map()

        // 1. Print the section name
        sectionName = "name"
        output = await printIt(sectionName, section.signature.name, w =>
          `## ${w}`
        )
        output && sectionOutput.set(sectionName, output)

        // 2. Print the signature
        sectionName = "signature"
        output = await printIt(sectionName, work[sectionName], w => {
          return `${w.access} `+
                 `${w.modifiers.length?w.modifiers.join(" ")+" ":""}`+
                 `*${w.type}* **${w.name}**`+
                 `(${w.parameters.join(", ")})`
        })
        output && sectionOutput.set(sectionName, output)

        // 2. Print the section description
        sectionName = "description"
        output = await printIt(sectionName, work[sectionName], w =>
          w.length ? w.map(line => line.trim()).join("\n") : ""
        )
        output && sectionOutput.set(sectionName, output)

        // 3. Print the section parameters
        sectionName = "param"
        output = await printIt(sectionName, work[sectionName], w => {
          const params = w.map(p => {

            // capture detailed name info
            let optionalParam, paramName, defaultValue

            // Determine if this is an optional parameter
            const optionalMatch = p.name.match(/^\[(.*)\]$/)
            if(optionalMatch) {
              optionalParam = true
              paramName = optionalMatch[1]
            } else {
              paramName = p.name
            }

            // Determine if there is a default value
            const defaultMatch = paramName.match(/(.*)=(.*)/)
            defaultValue = defaultMatch ? defaultMatch[2] : null
            paramName = defaultMatch ? defaultMatch[1] : paramName

            let optionalAndOrDefault = optionalParam || defaultValue
              ?(() => {
                if(optionalParam && defaultValue)
                  return ` (Optional. Default: ${defaultValue})`
                else if(optionalParam)
                  return " (Optional)"
                else if(defaultValue)
                  return ` (Default: ${defaultValue})`
                else
                  throw new Error("Uhm, we seem to have hit a bump.")
              })()
              : ""

            const content = p.content
            while(content.length && (!content.at(0) || !content.at(-1))) {
              if(!content.at(0))
                content.shift()

              if(!content.at(-1))
                content.pop()
            }

            return `**${paramName}** *${p.type}${optionalAndOrDefault}*\n\n` +
                    `: ${content.map(c => c.trim()).join(" ")}`
          }) ?? []
          return params.join("\n")
        })
        output && sectionOutput.set(sectionName, output)

        // 4. Print the section return
        output = await printIt(sectionName, work[sectionName], w => w
          ? `### Returns\n\n**${w.type}** `+
            `${w.content?.map(c => c.trim()).join(" ") ?? ""}`
          : ""
        )
        output && sectionOutput.set(sectionName, output)

        // 5. Print the section example
        sectionName = "example"
        output = await printIt(sectionName, work[sectionName], w => w.length
          ? "### Example\n\n" + w.join("\n")
          : ""
        )
        output && sectionOutput.set(sectionName, output)
        moduleOutput.push(Array.from(sectionOutput.values()).join("\n\n"))
      }

      debug(`Printing complete for module \`${moduleName}\``, 3)

      const joinedOutput = moduleOutput.join("\n")
      const finalOutput = await hook(
        END, {
          moduleName,
          moduleContent: joinedOutput
        }
      ) ?? joinedOutput

      return {
        status: "success",
        message: "File printed successfully",
        destFile: `${moduleName}${this.documentExtension}`,
        destContent: finalOutput,
      }
    },

    /**
     * Wraps text to a specified width with optional indentation
     *
     * @param {string} str - The text to wrap
     * @param {number} [wrapAt] - The column at which to wrap the text
     * @param {number} [indentAt] - The number of spaces to indent wrapped lines
     * @returns {string} The wrapped text
     */
    wrap(str, wrapAt = 80, indentAt = 0) {
      const sections = str.split("\n").map(section => {
        let parts = section.split(" ")
        let inCodeBlock = false
        let isStartOfLine = true // Start of each section is start of line

        // Preserve leading space if it existed
        if(section[0] === " ")
          parts = ["", ...parts]

        let running = 0

        parts = parts.map(part => {
          // Only check for code block if we're at start of line
          if(isStartOfLine && /^```(?:\w+)?$/.test(part)) {
            inCodeBlock = !inCodeBlock
            running += part.length + 1
            isStartOfLine = false
            return part
          }

          if(part[0] === "\n") {
            running = 0
            isStartOfLine = true // Next part will be at start of line
            return part
          }

          running += part.length + 1
          isStartOfLine = false // No longer at start of line

          if(!inCodeBlock && running >= wrapAt) {
            running = part.length + indentAt
            isStartOfLine = true // After newline, next part will be at start
            return "\n" + " ".repeat(indentAt) + part
          }

          return part
        })

        return parts
          .join(" ")
          .split("\n")
          .map(line => line.trimEnd())
          .join("\n")
      })

      return sections.join("\n")
    },
  },
]

export const contracts = [
  `
---
provides:
  root:
    dataType: object
    contains:
      functions:
        dataType: object[]
        contains:
          name:
            dataType: string
          description:
            dataType: string[]
          param:
            dataType: object[]
            contains:
              type:
                dataType: string
              name:
                dataType: string
              content:
                dataType: string[]
          return:
            dataType: object
            contains:
              type:
                dataType: string
              content:
                dataType: string[]
          example:
            dataType: string[]
`,
  `
---
accepts:
  root:
    dataType: object
    required: true
    contains:
      functions:
        dataType: object[]
        required: true
        contains:
          name:
            dataType: string
            required: true  # Used in sorting and section headers
          description:
            dataType: string[]  # Optional, handled gracefully if missing
          param:
            dataType: object[]
            contains:
              type:
                dataType: string|string[]
                required: true  # Used in param formatting
              name:
                dataType: string
                required: true  # Used in param formatting
              content:
                dataType: string[]
                required: true  # Used for param descriptions
          return:
            dataType: object
            contains:
              type:
                dataType: string|string[]
                required: true  # Used in return type display
              content:
                dataType: string[]  # Optional, handled if missing
          example:
            dataType: string[]  # Optional, handled gracefully if missing
`,
]
